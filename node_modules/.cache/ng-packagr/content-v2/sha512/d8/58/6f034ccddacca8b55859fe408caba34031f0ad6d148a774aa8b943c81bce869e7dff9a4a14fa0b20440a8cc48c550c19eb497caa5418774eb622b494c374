{"hash":"8e89d8d755008e919561865c1a3e883ca3a19c11","fesm2022":[{"exports":["ArrayState","KeyValueState","KeyValuesState","State"],"facadeModuleId":"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/ngx-states.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/helpers/type.helper.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/base-state.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/state.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/array-state.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/key-value-state.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/key-values-state.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/public-api.mjs","/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/ngx-states.mjs"],"name":"ngx-states","type":"chunk","dynamicImports":[],"fileName":"ngx-states.mjs","implicitlyLoadedBefore":[],"importedBindings":{"rxjs":["BehaviorSubject"],"rxjs/operators":["filter","distinctUntilChanged","first","skip","map","tap"],"@ngneat/until-destroy":["untilDestroyed"]},"imports":["rxjs","rxjs/operators","@ngneat/until-destroy"],"modules":{"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/helpers/type.helper.mjs":{"code":"const isNullOrUndefined = (value) => {\n    return value === undefined || value === null;\n};\nfunction countArrayElements(arr) {\n    return arr.reduce((count, item) => count + (Array.isArray(item) ? countArrayElements(item) : 1), 0);\n}","originalLength":1414,"removedExports":[],"renderedExports":["isNullOrUndefined","countArrayElements"],"renderedLength":233},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/base-state.mjs":{"code":"class BaseState {\n    bypassChangeDetection = false;\n    prepareSubscription(data) {\n        if (typeof data.error === \"object\") {\n            data.callerComponent = data.error;\n            data.error = undefined;\n        }\n        if (typeof data.complete === \"object\") {\n            data.callerComponent = data.complete;\n            data.complete = undefined;\n        }\n        if (!isNullOrUndefined(data.callerComponent)) {\n            data.observable = data.observable.pipe(untilDestroyed(data.callerComponent));\n        }\n        if (typeof data.observer === 'function') {\n            return data.observable.subscribe(data.observer, data.error, data.complete);\n        }\n        else {\n            return data.observable.subscribe(data.observer);\n        }\n    }\n}","originalLength":3712,"removedExports":[],"renderedExports":["BaseState"],"renderedLength":770},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/state.mjs":{"code":"class State extends BaseState {\n    subject;\n    get state() {\n        return this.subject.asObservable();\n    }\n    get value() {\n        return this.subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this.subject = new BehaviorSubject(initialValue ?? null);\n    }\n    set(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this.subject.next(value);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}","originalLength":12657,"removedExports":[],"renderedExports":["State"],"renderedLength":2573},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/array-state.mjs":{"code":"class ArrayState extends BaseState {\n    subject;\n    get state() {\n        return this.subject.asObservable();\n    }\n    get value() {\n        return this.subject.getValue();\n    }\n    get length() {\n        return this.value.length;\n    }\n    includes(value) {\n        return this.value.includes(value);\n    }\n    hasItem(item, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof item === 'string' && !exactMatch) {\n                return record.some(i => i.includes(item));\n            }\n            else {\n                return record.includes(item);\n            }\n        }), distinctUntilChanged());\n    }\n    constructor(initialValue) {\n        super();\n        this.subject = new BehaviorSubject(initialValue ?? []);\n    }\n    set(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this.subject.next(structuredClone(value));\n        return this.state;\n    }\n    stateOfItem(predicate) {\n        return this.state.pipe(map(items => items.find(predicate)), filter((item) => item !== undefined), first());\n    }\n    stateOfItems(predicate) {\n        return this.state.pipe(map(items => items.filter(predicate)), distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)));\n    }\n    getFirstItem(predicate) {\n        return this.value.find(predicate);\n    }\n    getItems(predicate) {\n        return this.value.filter(predicate);\n    }\n    add(value, unique, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        const isUnique = unique ?? true;\n        if ((isUnique && !newSet.includes(value)) ||\n            !isUnique) {\n            newSet.push(value);\n            this.set(newSet);\n        }\n    }\n    update(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        this.set(newSet.map(x => (x !== value) ? x : value));\n    }\n    remove(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        this.set(newSet.filter(x => x !== value));\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}","originalLength":21564,"removedExports":[],"renderedExports":["ArrayState"],"renderedLength":4359},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/key-value-state.mjs":{"code":"class KeyValueState extends BaseState {\n    _subject;\n    _keySeparator = '####';\n    get state() {\n        return this._subject.asObservable();\n    }\n    stateOfKey(key, changedStateOnly = true) {\n        const state = this.state.pipe(filter(record => !isNullOrUndefined(record) &&\n            !isNullOrUndefined(record[key]) && !this.bypassChangeDetection), map(record => record[key]));\n        if (changedStateOnly) {\n            return state.pipe(distinctUntilChanged());\n        }\n        return state;\n    }\n    stateOfKeys(...keys) {\n        return this.stateOfKey(keys.join(this._keySeparator));\n    }\n    hasKey(key, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof key === 'string' && !exactMatch) {\n                return Object.keys(record).some(k => k.includes(key));\n            }\n            else {\n                return key in record;\n            }\n        }), distinctUntilChanged());\n    }\n    get keys() {\n        return Object.keys(this.value);\n    }\n    getKeysOfIndex(keyIndex) {\n        return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\n    }\n    get toArray() {\n        return Object.values(this.value);\n    }\n    get length() {\n        return this.toArray.length;\n    }\n    get toArrayState() {\n        return this.state.pipe(map(x => Object.values(x)));\n    }\n    get value() {\n        return this._subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this._subject = new BehaviorSubject(initialValue ?? {});\n    }\n    getValue(key) {\n        return this.value[key];\n    }\n    getValueByKeys(...keys) {\n        return this.value[keys.map(String).join(this._keySeparator)];\n    }\n    setValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = { ...this.value };\n        newSet[key] = value;\n        this._subject.next(newSet);\n        return this.state;\n    }\n    setValueByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.setValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    unset(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n        return this.state;\n    }\n    unsetByKeys(bypassChangeDetection = false, ...keys) {\n        return this.unset(keys.join(this._keySeparator), bypassChangeDetection);\n    }\n    reset(bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next({});\n        return this.state;\n    }\n    set(record, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next(record);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueSet(key, observer, error, complete, filterValue, callerComponent) {\n        let isValueFiltered = (typeof filterValue === 'boolean') ? filterValue : true;\n        let observable = this.state.pipe(map(value => value[key]), isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueChange(key, observer, error, complete, filterValue, callerComponent) {\n        let isValueFiltered = (typeof filterValue === 'boolean') ? filterValue : true;\n        let observable = this.state.pipe(map(value => value[key]), isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap(), distinctUntilChanged());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptyChange(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}","originalLength":29896,"removedExports":[],"renderedExports":["KeyValueState"],"renderedLength":5714},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/lib/states/key-values-state.mjs":{"code":"class KeyValuesState extends BaseState {\n    _subject;\n    _keySeparator = '####';\n    get state() {\n        return this._subject.asObservable();\n    }\n    stateOfKey(key, changedStateOnly = true) {\n        const state = this.state.pipe(filter(record => !isNullOrUndefined(record) &&\n            !isNullOrUndefined(record[key]) &&\n            !this.bypassChangeDetection), map(record => record[key]));\n        if (changedStateOnly) {\n            return state.pipe(distinctUntilChanged());\n        }\n        return state;\n    }\n    stateOfKeys(...keys) {\n        return this.stateOfKey(keys.join(this._keySeparator));\n    }\n    hasKey(key, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof key === 'string' && !exactMatch) {\n                return Object.keys(record).some(k => k.includes(key));\n            }\n            else {\n                return key in record;\n            }\n        }), distinctUntilChanged());\n    }\n    get keys() {\n        return Object.keys(this.value);\n    }\n    getKeysOfIndex(keyIndex) {\n        return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\n    }\n    get toArray() {\n        return Object.values(this.value);\n    }\n    get length() {\n        return countArrayElements(this.toArray);\n    }\n    get toArrayState() {\n        return this.state.pipe(map(x => Object.values(x)));\n    }\n    get value() {\n        return this._subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this._subject = new BehaviorSubject(initialValue ?? {});\n    }\n    getValue(key) {\n        return this.value[key];\n    }\n    getValueByKeys(...keys) {\n        return this.value[keys.map(String).join(this._keySeparator)];\n    }\n    setValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        newSet[key] = value;\n        this._subject.next(newSet);\n        return this.state;\n    }\n    removeValue(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n    }\n    setValuesByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.setValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    addToValue(key, value, unique, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const isUnique = unique ?? true;\n        const currentValue = this.getValue(key);\n        if (isUnique && currentValue?.some(x => JSON.stringify(x) === JSON.stringify(value))) {\n            return this.state;\n        }\n        this.setValue(key, [...this.getValue(key) || [], value]);\n        return this.state;\n    }\n    addToValueByKeys(value, unique, bypassChangeDetection = false, ...keys) {\n        return this.addToValue(keys.join(this._keySeparator), value, unique, bypassChangeDetection);\n    }\n    removeFromValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        if (this.value[key] === undefined) {\n            return this.state;\n        }\n        const newSet = this.value;\n        newSet[key] = newSet[key].filter(x => x !== value);\n        return this.set(newSet);\n    }\n    removeFromValueByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.removeFromValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    unset(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n        return this.state;\n    }\n    unsetByKeys(bypassChangeDetection = false, ...keys) {\n        return this.unset(keys.join(this._keySeparator), bypassChangeDetection);\n    }\n    set(record, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next(record);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueSet(key, observer, error, complete, filterValue, callerComponent) {\n        let observable = this.state.pipe(map(value => value[key]), filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueChange(key, observer, error, complete, filterValue, callerComponent) {\n        let observable = this.state.pipe(map(value => value[key]), distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)), filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptySet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptyChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    reset(bypassChangeDetection = false) {\n        this.set({}, bypassChangeDetection);\n    }\n}","originalLength":40141,"removedExports":[],"renderedExports":["KeyValuesState"],"renderedLength":8012},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of ngx-states\n */","originalLength":912,"removedExports":[],"renderedExports":[],"renderedLength":42},"/Users/tnemeth/Works/megant/dist/ngx-states/esm2022/ngx-states.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":496,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import { BehaviorSubject } from 'rxjs';\nimport { filter, distinctUntilChanged, first, skip, map, tap } from 'rxjs/operators';\nimport { untilDestroyed } from '@ngneat/until-destroy';\n\nconst isNullOrUndefined = (value) => {\n    return value === undefined || value === null;\n};\nfunction countArrayElements(arr) {\n    return arr.reduce((count, item) => count + (Array.isArray(item) ? countArrayElements(item) : 1), 0);\n}\n\nclass BaseState {\n    bypassChangeDetection = false;\n    prepareSubscription(data) {\n        if (typeof data.error === \"object\") {\n            data.callerComponent = data.error;\n            data.error = undefined;\n        }\n        if (typeof data.complete === \"object\") {\n            data.callerComponent = data.complete;\n            data.complete = undefined;\n        }\n        if (!isNullOrUndefined(data.callerComponent)) {\n            data.observable = data.observable.pipe(untilDestroyed(data.callerComponent));\n        }\n        if (typeof data.observer === 'function') {\n            return data.observable.subscribe(data.observer, data.error, data.complete);\n        }\n        else {\n            return data.observable.subscribe(data.observer);\n        }\n    }\n}\n\nclass State extends BaseState {\n    subject;\n    get state() {\n        return this.subject.asObservable();\n    }\n    get value() {\n        return this.subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this.subject = new BehaviorSubject(initialValue ?? null);\n    }\n    set(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this.subject.next(value);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}\n\nclass ArrayState extends BaseState {\n    subject;\n    get state() {\n        return this.subject.asObservable();\n    }\n    get value() {\n        return this.subject.getValue();\n    }\n    get length() {\n        return this.value.length;\n    }\n    includes(value) {\n        return this.value.includes(value);\n    }\n    hasItem(item, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof item === 'string' && !exactMatch) {\n                return record.some(i => i.includes(item));\n            }\n            else {\n                return record.includes(item);\n            }\n        }), distinctUntilChanged());\n    }\n    constructor(initialValue) {\n        super();\n        this.subject = new BehaviorSubject(initialValue ?? []);\n    }\n    set(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this.subject.next(structuredClone(value));\n        return this.state;\n    }\n    stateOfItem(predicate) {\n        return this.state.pipe(map(items => items.find(predicate)), filter((item) => item !== undefined), first());\n    }\n    stateOfItems(predicate) {\n        return this.state.pipe(map(items => items.filter(predicate)), distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)));\n    }\n    getFirstItem(predicate) {\n        return this.value.find(predicate);\n    }\n    getItems(predicate) {\n        return this.value.filter(predicate);\n    }\n    add(value, unique, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        const isUnique = unique ?? true;\n        if ((isUnique && !newSet.includes(value)) ||\n            !isUnique) {\n            newSet.push(value);\n            this.set(newSet);\n        }\n    }\n    update(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        this.set(newSet.map(x => (x !== value) ? x : value));\n    }\n    remove(value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        this.set(newSet.filter(x => x !== value));\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}\n\nclass KeyValueState extends BaseState {\n    _subject;\n    _keySeparator = '####';\n    get state() {\n        return this._subject.asObservable();\n    }\n    stateOfKey(key, changedStateOnly = true) {\n        const state = this.state.pipe(filter(record => !isNullOrUndefined(record) &&\n            !isNullOrUndefined(record[key]) && !this.bypassChangeDetection), map(record => record[key]));\n        if (changedStateOnly) {\n            return state.pipe(distinctUntilChanged());\n        }\n        return state;\n    }\n    stateOfKeys(...keys) {\n        return this.stateOfKey(keys.join(this._keySeparator));\n    }\n    hasKey(key, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof key === 'string' && !exactMatch) {\n                return Object.keys(record).some(k => k.includes(key));\n            }\n            else {\n                return key in record;\n            }\n        }), distinctUntilChanged());\n    }\n    get keys() {\n        return Object.keys(this.value);\n    }\n    getKeysOfIndex(keyIndex) {\n        return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\n    }\n    get toArray() {\n        return Object.values(this.value);\n    }\n    get length() {\n        return this.toArray.length;\n    }\n    get toArrayState() {\n        return this.state.pipe(map(x => Object.values(x)));\n    }\n    get value() {\n        return this._subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this._subject = new BehaviorSubject(initialValue ?? {});\n    }\n    getValue(key) {\n        return this.value[key];\n    }\n    getValueByKeys(...keys) {\n        return this.value[keys.map(String).join(this._keySeparator)];\n    }\n    setValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = { ...this.value };\n        newSet[key] = value;\n        this._subject.next(newSet);\n        return this.state;\n    }\n    setValueByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.setValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    unset(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n        return this.state;\n    }\n    unsetByKeys(bypassChangeDetection = false, ...keys) {\n        return this.unset(keys.join(this._keySeparator), bypassChangeDetection);\n    }\n    reset(bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next({});\n        return this.state;\n    }\n    set(record, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next(record);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueSet(key, observer, error, complete, filterValue, callerComponent) {\n        let isValueFiltered = (typeof filterValue === 'boolean') ? filterValue : true;\n        let observable = this.state.pipe(map(value => value[key]), isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueChange(key, observer, error, complete, filterValue, callerComponent) {\n        let isValueFiltered = (typeof filterValue === 'boolean') ? filterValue : true;\n        let observable = this.state.pipe(map(value => value[key]), isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap(), distinctUntilChanged());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptyChange(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n}\n\nclass KeyValuesState extends BaseState {\n    _subject;\n    _keySeparator = '####';\n    get state() {\n        return this._subject.asObservable();\n    }\n    stateOfKey(key, changedStateOnly = true) {\n        const state = this.state.pipe(filter(record => !isNullOrUndefined(record) &&\n            !isNullOrUndefined(record[key]) &&\n            !this.bypassChangeDetection), map(record => record[key]));\n        if (changedStateOnly) {\n            return state.pipe(distinctUntilChanged());\n        }\n        return state;\n    }\n    stateOfKeys(...keys) {\n        return this.stateOfKey(keys.join(this._keySeparator));\n    }\n    hasKey(key, exactMatch = true) {\n        return this.state.pipe(map(record => {\n            if (typeof key === 'string' && !exactMatch) {\n                return Object.keys(record).some(k => k.includes(key));\n            }\n            else {\n                return key in record;\n            }\n        }), distinctUntilChanged());\n    }\n    get keys() {\n        return Object.keys(this.value);\n    }\n    getKeysOfIndex(keyIndex) {\n        return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\n    }\n    get toArray() {\n        return Object.values(this.value);\n    }\n    get length() {\n        return countArrayElements(this.toArray);\n    }\n    get toArrayState() {\n        return this.state.pipe(map(x => Object.values(x)));\n    }\n    get value() {\n        return this._subject.getValue();\n    }\n    constructor(initialValue) {\n        super();\n        this._subject = new BehaviorSubject(initialValue ?? {});\n    }\n    getValue(key) {\n        return this.value[key];\n    }\n    getValueByKeys(...keys) {\n        return this.value[keys.map(String).join(this._keySeparator)];\n    }\n    setValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        newSet[key] = value;\n        this._subject.next(newSet);\n        return this.state;\n    }\n    removeValue(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n    }\n    setValuesByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.setValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    addToValue(key, value, unique, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const isUnique = unique ?? true;\n        const currentValue = this.getValue(key);\n        if (isUnique && currentValue?.some(x => JSON.stringify(x) === JSON.stringify(value))) {\n            return this.state;\n        }\n        this.setValue(key, [...this.getValue(key) || [], value]);\n        return this.state;\n    }\n    addToValueByKeys(value, unique, bypassChangeDetection = false, ...keys) {\n        return this.addToValue(keys.join(this._keySeparator), value, unique, bypassChangeDetection);\n    }\n    removeFromValue(key, value, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        if (this.value[key] === undefined) {\n            return this.state;\n        }\n        const newSet = this.value;\n        newSet[key] = newSet[key].filter(x => x !== value);\n        return this.set(newSet);\n    }\n    removeFromValueByKeys(value, bypassChangeDetection = false, ...keys) {\n        return this.removeFromValue(keys.join(this._keySeparator), value, bypassChangeDetection);\n    }\n    unset(key, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        const newSet = this.value;\n        delete newSet[key];\n        this._subject.next(newSet);\n        return this.state;\n    }\n    unsetByKeys(bypassChangeDetection = false, ...keys) {\n        return this.unset(keys.join(this._keySeparator), bypassChangeDetection);\n    }\n    set(record, bypassChangeDetection = false) {\n        this.bypassChangeDetection = bypassChangeDetection;\n        this._subject.next(record);\n        return this.state;\n    }\n    onSet(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onChange(observer, error, complete, callerComponent) {\n        let observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueSet(key, observer, error, complete, filterValue, callerComponent) {\n        let observable = this.state.pipe(map(value => value[key]), filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onValueChange(key, observer, error, complete, filterValue, callerComponent) {\n        let observable = this.state.pipe(map(value => value[key]), distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)), filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFirstSet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptySet(observer, error, complete) {\n        const observable = this.state.pipe(filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFirstNonEmptyChange(observer, error, complete) {\n        const observable = this.state.pipe(distinctUntilChanged(), filter(x => !isNullOrUndefined(x) &&\n            Object.keys(x).length > 0 &&\n            !this.bypassChangeDetection), first());\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete\n        });\n    }\n    onFromSecondSet(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    onFromSecondChange(observer, error, complete, callerComponent) {\n        const observable = this.state.pipe(untilDestroyed(callerComponent), distinctUntilChanged(), filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection), skip(1));\n        return this.prepareSubscription({\n            observable,\n            observer,\n            error,\n            complete,\n            callerComponent\n        });\n    }\n    reset(bypassChangeDetection = false) {\n        this.set({}, bypassChangeDetection);\n    }\n}\n\n/*\n * Public API Surface of ngx-states\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayState, KeyValueState, KeyValuesState, State };\n//# sourceMappingURL=ngx-states.mjs.map\n","map":null,"preliminaryFileName":"ngx-states.mjs","sourcemapFileName":"ngx-states.mjs.map"},{"fileName":"ngx-states.mjs.map","needsCodeReference":false,"originalFileName":null,"source":"{\"version\":3,\"file\":\"ngx-states.mjs\",\"sources\":[\"../../../projects/ngx-states/src/lib/helpers/type.helper.ts\",\"../../../projects/ngx-states/src/lib/states/base-state.ts\",\"../../../projects/ngx-states/src/lib/states/state.ts\",\"../../../projects/ngx-states/src/lib/states/array-state.ts\",\"../../../projects/ngx-states/src/lib/states/key-value-state.ts\",\"../../../projects/ngx-states/src/lib/states/key-values-state.ts\",\"../../../projects/ngx-states/src/public-api.ts\",\"../../../projects/ngx-states/src/ngx-states.ts\"],\"sourcesContent\":[\"export const isNullOrUndefined = (value: unknown): value is null | undefined => {\\n  return value === undefined || value === null;\\n}\\n\\nexport function countArrayElements(arr: any[]): number {\\n  return arr.reduce((count, item) => count + (Array.isArray(item) ? countArrayElements(item) : 1), 0);\\n}\\n\",\"import { Subscription } from \\\"rxjs\\\";\\nimport { SubscriptionData } from \\\"../types/subscription-data\\\";\\nimport { isNullOrUndefined } from \\\"../helpers/type.helper\\\";\\nimport { untilDestroyed } from \\\"@ngneat/until-destroy\\\";\\n\\nexport abstract class BaseState {\\n  protected bypassChangeDetection: boolean = false;\\n\\n  protected prepareSubscription(data: SubscriptionData): Subscription {\\n    if (typeof data.error === \\\"object\\\") {\\n      data.callerComponent = data.error;\\n      data.error = undefined;\\n    }\\n\\n    if (typeof data.complete === \\\"object\\\") {\\n      data.callerComponent = data.complete;\\n      data.complete = undefined;\\n    }\\n\\n    if (!isNullOrUndefined(data.callerComponent)) {\\n      data.observable = data.observable.pipe(untilDestroyed(data.callerComponent));\\n    }\\n\\n    if (typeof data.observer === 'function') {\\n      return data.observable.subscribe(data.observer, data.error, data.complete);\\n    } else {\\n      return data.observable.subscribe(data.observer);\\n    }\\n  }\\n}\\n\",\"import { BehaviorSubject, Observable, PartialObserver, Subscription } from \\\"rxjs\\\";\\nimport { distinctUntilChanged, filter, first, skip } from \\\"rxjs/operators\\\";\\nimport { isNullOrUndefined } from \\\"../helpers/type.helper\\\";\\nimport { BaseState } from \\\"./base-state\\\";\\n\\nexport class State<T> extends BaseState {\\n  protected subject: BehaviorSubject<T>;\\n\\n  public get state(): Observable<T> {\\n    return this.subject.asObservable();\\n  }\\n\\n  public get value(): T {\\n    return this.subject.getValue();\\n  }\\n\\n  constructor(initialValue?: T) {\\n    super();\\n    this.subject = new BehaviorSubject<T>(initialValue ?? null as T);\\n  }\\n\\n  public set(value: T, bypassChangeDetection = false): Observable<T> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    this.subject.next(value);\\n    return this.state;\\n  }\\n\\n  public onSet(observer: (value: T) => void, callerComponent?: object): void;\\n  public onSet(\\n    observer: PartialObserver<T>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n    );\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onChange(observer: (value: T) => void, callerComponent?: object): void;\\n  public onChange(\\n    observer: PartialObserver<T>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFirstSet(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstChange(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFromSecondSet(observer: (value: T) => void, callerComponent?: object): void;\\n  public onFromSecondSet(\\n    observer: PartialObserver<T>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFromSecondChange(observer: (value: T) => void, callerComponent?: object): void;\\n  public onFromSecondChange(\\n    observer: PartialObserver<T>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(observer?: ((value: T) => void) | PartialObserver<T>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n}\\n\",\"import { BehaviorSubject, Observable, PartialObserver, Subscription } from \\\"rxjs\\\";\\nimport { distinctUntilChanged, filter, first, map, skip } from \\\"rxjs/operators\\\";\\nimport { isNullOrUndefined } from \\\"../helpers/type.helper\\\";\\nimport { BaseState } from \\\"./base-state\\\";\\n\\nexport class ArrayState<T> extends BaseState {\\n  protected subject: BehaviorSubject<T[]>;\\n\\n  public get state(): Observable<T[]> {\\n    return this.subject.asObservable();\\n  }\\n\\n  public get value(): T[] {\\n    return this.subject.getValue();\\n  }\\n\\n  public get length(): number {\\n    return this.value.length;\\n  }\\n\\n  public includes(value: T): boolean {\\n    return this.value.includes(value);\\n  }\\n\\n  public hasItem(item: T, exactMatch = true): Observable<boolean> {\\n    return this.state.pipe(\\n      map(record => {\\n        if (typeof item === 'string' && !exactMatch) {\\n          return record.some(i => (i as unknown as string).includes(item));\\n        } else {\\n          return record.includes(item);\\n        }\\n      }),\\n      distinctUntilChanged()\\n    );\\n  }\\n\\n  constructor(initialValue?: T[]) {\\n    super();\\n    this.subject = new BehaviorSubject<T[]>(initialValue ?? []);\\n  }\\n\\n  public set(value: T[], bypassChangeDetection = false): Observable<T[]> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    this.subject.next(structuredClone(value));\\n    return this.state;\\n  }\\n\\n  public stateOfItem(predicate: (item: T) => boolean): Observable<T> {\\n    return this.state.pipe(\\n      map(items => items.find(predicate)),\\n      filter((item): item is T => item !== undefined),\\n      first());\\n  }\\n\\n  public stateOfItems(predicate: (item: T) => boolean): Observable<T[]> {\\n    return this.state.pipe(map(items => items.filter(predicate)),\\n      distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr))\\n    );\\n  }\\n\\n  public getFirstItem(predicate: (item: T) => boolean): T | undefined {\\n    return this.value.find(predicate);\\n  }\\n\\n  public getItems(predicate: (item: T) => boolean): T[] {\\n    return this.value.filter(predicate);\\n  }\\n\\n  public add(value: T, unique?: boolean, bypassChangeDetection = false): void {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    const isUnique = unique ?? true;\\n    if ((isUnique && !newSet.includes(value)) ||\\n        !isUnique) {\\n        newSet.push(value);\\n        this.set(newSet);\\n    }\\n  }\\n\\n  public update(value: T, bypassChangeDetection = false): void {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    this.set(newSet.map(x => (x !== value) ? x : value));\\n  }\\n\\n  public remove(value: T, bypassChangeDetection = false): void {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    this.set(newSet.filter(x => x !== value));\\n  }\\n\\n  public onSet(\\n    observer: PartialObserver<T[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: T[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: T[]) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: T[]) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onChange(\\n    observer: PartialObserver<T[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: (value: T[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: (value: T[]) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: PartialObserver<T[]>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection));\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFirstSet(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection),\\n      first()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstChange(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && x.length > 0 && !this.bypassChangeDetection),\\n      first()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFromSecondSet(\\n    observer: PartialObserver<T[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: (value: T[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: PartialObserver<T[]>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: PartialObserver<T[]>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFromSecondChange(\\n    observer: PartialObserver<T[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: (value: T[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: PartialObserver<T[]>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: PartialObserver<T[]>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(observer?: ((value: T[]) => void) | PartialObserver<T[]>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n}\\n\",\"import { BehaviorSubject, Observable, PartialObserver, Subscription } from \\\"rxjs\\\";\\nimport { untilDestroyed } from \\\"@ngneat/until-destroy\\\";\\nimport { distinctUntilChanged, filter, first, map, skip, tap } from \\\"rxjs/operators\\\";\\nimport { isNullOrUndefined } from \\\"../helpers/type.helper\\\";\\nimport { BaseState } from \\\"./base-state\\\";\\n\\nexport class KeyValueState<KEY extends string | number | symbol, VALUE> extends BaseState {\\n\\n  private _subject: BehaviorSubject<Record<KEY, VALUE>>;\\n  private readonly _keySeparator = '####';\\n\\n  public get state(): Observable<Record<KEY, VALUE>> {\\n    return this._subject.asObservable();\\n  }\\n\\n  public stateOfKey(key: KEY, changedStateOnly = true): Observable<VALUE> {\\n    const state = this.state.pipe(\\n      filter(record =>\\n        !isNullOrUndefined(record) &&\\n      !isNullOrUndefined(record[key]) && !this.bypassChangeDetection),\\n      map(record => record[key] as VALUE)\\n    );\\n\\n    if (changedStateOnly) {\\n      return state.pipe(distinctUntilChanged())\\n    }\\n\\n    return state;\\n  }\\n\\n  public stateOfKeys(...keys: any[]): Observable<VALUE> {\\n    return this.stateOfKey(keys.join(this._keySeparator) as KEY);\\n  }\\n\\n  public hasKey(key: KEY, exactMatch = true): Observable<boolean> {\\n      return this.state.pipe(\\n        map(record => {\\n          if (typeof key === 'string' && !exactMatch) {\\n            return Object.keys(record).some(k => k.includes(key));\\n          } else {\\n            return key in record;\\n          }\\n        }),\\n        distinctUntilChanged()\\n      );\\n  }\\n\\n  public get keys(): KEY[] {\\n    return Object.keys(this.value) as KEY[];\\n  }\\n\\n  public getKeysOfIndex(keyIndex: number): string[] {\\n    return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\\n  }\\n\\n  public get toArray(): VALUE[] {\\n    return Object.values(this.value);\\n  }\\n\\n  public get length(): number {\\n    return this.toArray.length;\\n  }\\n\\n  public get toArrayState(): Observable<VALUE[]> {\\n    return this.state.pipe(map(x => Object.values(x) as unknown as VALUE[]));\\n  }\\n\\n  public get value(): Record<KEY, VALUE> {\\n    return this._subject.getValue();\\n  }\\n\\n  constructor(initialValue?: Record<KEY, VALUE>) {\\n    super();\\n    this._subject = new BehaviorSubject<Record<KEY, VALUE>>(initialValue ?? {} as Record<KEY, VALUE>);\\n  }\\n\\n  public getValue(key: KEY): VALUE {\\n    return this.value[key];\\n  }\\n\\n  public getValueByKeys(...keys: any[]): VALUE {\\n    return this.value[keys.map(String).join(this._keySeparator) as KEY];\\n  }\\n\\n  public setValue(key: KEY, value: VALUE, bypassChangeDetection = false): Observable<Record<KEY, VALUE>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = {...this.value};\\n    newSet[key] = value;\\n    this._subject.next(newSet);\\n    return this.state;\\n  }\\n\\n  public setValueByKeys(value: VALUE, bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE>> {\\n    return this.setValue(keys.join(this._keySeparator) as KEY, value, bypassChangeDetection);\\n  }\\n\\n  public unset(key: KEY, bypassChangeDetection = false): Observable<Record<KEY, VALUE>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    delete newSet[key];\\n    this._subject.next(newSet);\\n    return this.state;\\n  }\\n\\n  public unsetByKeys(bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE>> {\\n    return this.unset(keys.join(this._keySeparator) as KEY, bypassChangeDetection);\\n  }\\n\\n  public reset(bypassChangeDetection = false): Observable<Record<KEY, VALUE>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    this._subject.next({} as Record<KEY, VALUE>);\\n    return this.state;\\n  }\\n\\n  public set(record: Record<KEY, VALUE>, bypassChangeDetection = false): Observable<Record<KEY, VALUE>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    this._subject.next(record);\\n    return this.state;\\n  }\\n\\n  public onSet(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: PartialObserver<Record<KEY, VALUE>>,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(observer?: ((value: Record<KEY, VALUE>) => void) | PartialObserver<Record<KEY, VALUE>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: PartialObserver<Record<KEY, VALUE>>,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(observer?: ((value: Record<KEY, VALUE>) => void) | PartialObserver<Record<KEY, VALUE>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object | boolean\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    filterValue?: boolean,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: PartialObserver<VALUE>,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: PartialObserver<VALUE>,\\n    filterValue?: boolean | object,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(key: KEY, observer?: ((value: VALUE) => void) | PartialObserver<VALUE>, error?: (error: any) => void, complete?: () => void, filterValue?: boolean, callerComponent?: object): Subscription {\\n    let isValueFiltered: boolean = (typeof filterValue === 'boolean') ? filterValue : true;\\n\\n    let observable: Observable<VALUE> = this.state.pipe(\\n      map(value => value[key]),\\n      isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object | boolean\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    filterValue?: boolean,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: PartialObserver<VALUE>,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: PartialObserver<VALUE>,\\n    filterValue?: boolean | object,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(key: KEY, observer?: ((value: VALUE) => void) | PartialObserver<VALUE>, error?: (error: any) => void, complete?: () => void, filterValue?: boolean, callerComponent?: object): Subscription {\\n    let isValueFiltered: boolean = (typeof filterValue === 'boolean') ? filterValue : true;\\n\\n    let observable: Observable<VALUE> = this.state.pipe(\\n      map(value => value[key]),\\n      isValueFiltered ? filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection) : tap(),\\n      distinctUntilChanged()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFirstChange(observer?: ((value: Record<KEY, VALUE>) => void) | PartialObserver<Record<KEY, VALUE>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) &&\\n        !this.bypassChangeDetection),\\n      first()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstNonEmptyChange(observer?: ((value: Record<KEY, VALUE>) => void) | PartialObserver<Record<KEY, VALUE>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) &&\\n        Object.keys(x).length > 0 &&\\n        !this.bypassChangeDetection\\n      ),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFromSecondChange(\\n    observer: PartialObserver<Record<KEY, VALUE>>,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: (value: Record<KEY, VALUE>) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(observer?: ((value: Record<KEY, VALUE>) => void) | PartialObserver<Record<KEY, VALUE>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    const observable = this.state.pipe(\\n      untilDestroyed(callerComponent),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n}\\n\",\"import { BehaviorSubject, Observable, PartialObserver, Subscription } from \\\"rxjs\\\";\\nimport { untilDestroyed } from \\\"@ngneat/until-destroy\\\";\\nimport { distinctUntilChanged, filter, first, map, skip } from \\\"rxjs/operators\\\";\\nimport { isNullOrUndefined, countArrayElements } from \\\"../helpers/type.helper\\\";\\nimport { BaseState } from \\\"./base-state\\\";\\n\\nexport class KeyValuesState<KEY extends string | number | symbol, VALUE> extends BaseState {\\n\\n  private _subject: BehaviorSubject<Record<KEY, VALUE[]>>;\\n  private readonly _keySeparator = '####';\\n\\n  public get state(): Observable<Record<KEY, VALUE[]>> {\\n    return this._subject.asObservable();\\n  }\\n\\n  public stateOfKey(key: KEY, changedStateOnly = true): Observable<VALUE[]> {\\n    const state = this.state.pipe(\\n      filter(record =>\\n        !isNullOrUndefined(record) &&\\n        !isNullOrUndefined(record[key]) &&\\n        !this.bypassChangeDetection\\n      ),\\n      map(record => record[key] as VALUE[])\\n    );\\n\\n    if (changedStateOnly) {\\n      return state.pipe(distinctUntilChanged())\\n    }\\n\\n    return state;\\n  }\\n\\n  public stateOfKeys(...keys: any[]): Observable<VALUE[]> {\\n    return this.stateOfKey(keys.join(this._keySeparator) as KEY);\\n  }\\n\\n  public hasKey(key: KEY, exactMatch = true): Observable<boolean> {\\n    return this.state.pipe(\\n      map(record => {\\n        if (typeof key === 'string' && !exactMatch) {\\n          return Object.keys(record).some(k => k.includes(key));\\n        } else {\\n          return key in record;\\n        }\\n      }),\\n      distinctUntilChanged()\\n    );\\n  }\\n\\n  public get keys(): KEY[] {\\n    return Object.keys(this.value) as KEY[];\\n  }\\n\\n  public getKeysOfIndex(keyIndex: number): string[] {\\n    return this.keys.map(key => key.toString().split(this._keySeparator)[keyIndex]);\\n  }\\n\\n  public get toArray(): VALUE[][] {\\n    return Object.values(this.value);\\n  }\\n\\n  public get length(): number {\\n    return countArrayElements(this.toArray);\\n  }\\n\\n  public get toArrayState(): Observable<VALUE[]> {\\n    return this.state.pipe(map(x => Object.values(x) as unknown as VALUE[]));\\n  }\\n\\n  public get value(): Record<KEY, VALUE[]> {\\n    return this._subject.getValue();\\n  }\\n\\n  constructor(initialValue?: Record<KEY, VALUE[]>) {\\n    super();\\n    this._subject = new BehaviorSubject<Record<KEY, VALUE[]>>(initialValue ?? {} as Record<KEY, VALUE[]>);\\n  }\\n\\n  public getValue(key: KEY): VALUE[] {\\n    return this.value[key];\\n  }\\n\\n  public getValueByKeys(...keys: any[]): VALUE[] {\\n    return this.value[keys.map(String).join(this._keySeparator) as KEY];\\n  }\\n\\n  public setValue(key: KEY, value: VALUE[], bypassChangeDetection = false): Observable<Record<KEY, VALUE[]>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    newSet[key] = value;\\n    this._subject.next(newSet);\\n    return this.state;\\n  }\\n\\n  public removeValue(key: KEY, bypassChangeDetection = false): void {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    delete newSet[key];\\n    this._subject.next(newSet);\\n  }\\n\\n  public setValuesByKeys(value: VALUE[], bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE[]>> {\\n    return this.setValue(keys.join(this._keySeparator) as KEY, value, bypassChangeDetection);\\n  }\\n\\n  public addToValue(key: KEY, value: VALUE, unique?: boolean, bypassChangeDetection = false): Observable<Record<KEY, VALUE[]>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const isUnique = unique ?? true;\\n    const currentValue = this.getValue(key);\\n\\n    if (isUnique && currentValue?.some(x => JSON.stringify(x) === JSON.stringify(value))) {\\n      return this.state;\\n    }\\n\\n    this.setValue(key, [...this.getValue(key) || [], value]);\\n    return this.state;\\n  }\\n\\n  public addToValueByKeys(value: VALUE, unique?: boolean, bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE[]>> {\\n    return this.addToValue(keys.join(this._keySeparator) as KEY, value, unique, bypassChangeDetection);\\n  }\\n\\n  public removeFromValue(key: KEY, value: VALUE, bypassChangeDetection = false): Observable<Record<KEY, VALUE[]>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    if (this.value[key] === undefined) {\\n      return this.state;\\n    }\\n\\n    const newSet = this.value;\\n    newSet[key] = newSet[key].filter(x => x !== value);\\n    return this.set(newSet);\\n  }\\n\\n  public removeFromValueByKeys(value: VALUE, bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE[]>> {\\n    return this.removeFromValue(keys.join(this._keySeparator) as KEY, value, bypassChangeDetection);\\n  }\\n\\n  public unset(key: KEY, bypassChangeDetection = false): Observable<Record<KEY, VALUE[]>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    const newSet = this.value;\\n    delete newSet[key];\\n    this._subject.next(newSet);\\n    return this.state;\\n  }\\n\\n  public unsetByKeys(bypassChangeDetection = false, ...keys: any[]): Observable<Record<KEY, VALUE[]>> {\\n    return this.unset(keys.join(this._keySeparator) as KEY, bypassChangeDetection);\\n  }\\n\\n  public set(record: Record<KEY, VALUE[]>, bypassChangeDetection = false): Observable<Record<KEY, VALUE[]>> {\\n    this.bypassChangeDetection = bypassChangeDetection;\\n    this._subject.next(record);\\n    return this.state;\\n  }\\n\\n  public onSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: (value: Record<KEY, VALUE[]>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onSet(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: (value: Record<KEY, VALUE[]>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onChange(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object | boolean\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    filterValue?: boolean,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: PartialObserver<VALUE[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(\\n    key: KEY,\\n    observer: PartialObserver<VALUE[]>,\\n    filterValue?: boolean | object,\\n    callerComponent?: object\\n  ): void;\\n  public onValueSet(key: KEY, observer?: ((value: VALUE[]) => void) | PartialObserver<VALUE[]>, error?: (error: any) => void, complete?: () => void, filterValue?: boolean, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      map(value => value[key]),\\n      filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object | boolean\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: (value: VALUE[]) => void,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    filterValue?: boolean,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: PartialObserver<VALUE[]>,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(\\n    key: KEY,\\n    observer: PartialObserver<VALUE[]>,\\n    filterValue?: boolean | object,\\n    callerComponent?: object\\n  ): void;\\n  public onValueChange(key: KEY, observer?: ((value: VALUE[]) => void) | PartialObserver<VALUE[]>, error?: (error: any) => void, complete?: () => void, filterValue?: boolean, callerComponent?: object): Subscription {\\n    let observable = this.state.pipe(\\n      map(value => value[key]),\\n      distinctUntilChanged((prev, curr) => JSON.stringify(prev) === JSON.stringify(curr)),\\n      filter(value => !isNullOrUndefined(value) && !this.bypassChangeDetection)\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFirstSet(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      first()\\n    );\\n\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstChange(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstNonEmptySet(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      filter(x =>\\n        !isNullOrUndefined(x) &&\\n        Object.keys(x).length > 0 &&\\n        !this.bypassChangeDetection\\n      ),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFirstNonEmptyChange(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void): Subscription {\\n    const observable = this.state.pipe(\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) &&\\n        Object.keys(x).length > 0 &&\\n        !this.bypassChangeDetection\\n      ),\\n      first()\\n    )\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete\\n    });\\n  }\\n\\n  public onFromSecondSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: (value: Record<KEY, VALUE[]>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondSet(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    const observable = this.state.pipe(\\n      untilDestroyed(callerComponent),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public onFromSecondChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: (value: Record<KEY, VALUE[]>) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(\\n    observer: PartialObserver<Record<KEY, VALUE[]>>,\\n    error?: (error: any) => void,\\n    complete?: () => void,\\n    callerComponent?: object\\n  ): void;\\n  public onFromSecondChange(observer?: ((value: Record<KEY, VALUE[]>) => void) | PartialObserver<Record<KEY, VALUE[]>>, error?: (error: any) => void, complete?: () => void, callerComponent?: object): Subscription {\\n    const observable = this.state.pipe(\\n      untilDestroyed(callerComponent),\\n      distinctUntilChanged(),\\n      filter(x => !isNullOrUndefined(x) && !this.bypassChangeDetection),\\n      skip(1)\\n    );\\n    return this.prepareSubscription({\\n      observable,\\n      observer,\\n      error,\\n      complete,\\n      callerComponent\\n    });\\n  }\\n\\n  public reset(bypassChangeDetection = false): void {\\n    this.set({} as Record<KEY, VALUE[]>, bypassChangeDetection);\\n  }\\n}\\n\",\"/*\\n * Public API Surface of ngx-states\\n */\\n\\nexport * from './lib/states/state';\\nexport * from './lib/states/array-state';\\nexport * from './lib/states/key-value-state';\\nexport * from './lib/states/key-values-state';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}